module ExpConn;


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		choice at A
		{
			continue X;
		}
		or
		{
			2() from A to B;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	// CHECKME: orphans currently detected on local termination, not full system termination (same for stuck and deadlock)
	choice at A {
		1() from A to B;
		2() from A to C;
		3() from B to C;
		4() from C to A;
	} or {
		1b() from A to B;
		3() from B to C;  // -nolocalchoicecheck to show orphans
		4() from C to A;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		do Proto1Aux(A, B);  // Testing recvar name disambiguation
	}
}

global protocol Proto1Aux(role A, role B)
{
	rec X
	{
		2() from A to B;
		choice at A
		{
			continue X;
		}
		or
		{
			3() from A to B;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		rec X
		{
			choice at A
			{
				2() from A to B;
				choice at A
				{
					continue X;
				}
				or
				{
					3() from A to B;
				}
			}
			or
			{
				//4() from A to B;
				continue X;  // Testing unguarded shadowed recvars at different nestings
			}
			or
			{
				5() from A to B;
			}
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		choice at A
		{
			rec X
			{
				2() from A to B;
				continue X;
			}
		}
		or
		{
			rec X  // Testing shadowed unguarded recs
			{
				3() from A to B;
				continue X;
			}
		}
		or
		{
			4() from A to B;
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		rec X
		{
			2() from A to B;
			choice at A
			{
				continue X;  // Testing inlined-unfolding for shadowed recs
			}
			or
			{
				3() from A to B;
			}
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			2() from B to A;
			continue X;
		} or {
			1() from A to B;
			3() from B to A;  // Testing non-det unfair-transform ("unfairness" has the power to enforce a single case out of non-det options)
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			2() from B to A;
			continue X;  // Testing non-det unfair-transform
		} or {
			1() from A to B;
			3() from B to A;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			continue X;  // Testing non-det unfair-transform
		} or {
			1() from A to B;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	disconnect A and B;
	do Proto1Aux(A, B);
}

// Trivial test for "expressiveness" of aux -- but could just make explicit..  // CHECKME example where "aux" is fully needed
aux global protocol Proto1Aux(role A, role B)
{
	connect A to B;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			//1() from A to C;
			continue X;  // Testing fairness
		}
		or
		{
			2() from A to B;
			2() from A to C;
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		3() from B to C;
		4() from C to B;
		5() from B to C;
	}
	or
	{
		2() from A to B;
		3() from B to C;  // Syntactic merge means: non-det "squashed" so original choice path now ambiguous, so we need to act conservatively -- conservatively means squashed role needs to accept any incoming messages as a branch (to handle ambiguity) while not being allowed to make any output choices (only unary send allowed, so must be identical in all possibilities)
				// EFSM transform has to follow this intuition, full continuations after a non-det input choice have to be convservatively squashed (and if not squashable, then check model using unsquashed version) -- or implement as syntactic merge, and use original if not mergeable
		4() from C to B;
		6() from B to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C, role D)
{
	choice at A
	{
		1() from A to B;
		3() from B to C;
		3() from B to D;
		4() from C to D;
	}
	or
	{
		2() from A to B;
		3() from B to C;
		3() from B to D;
		5() from C to D;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C, role D)
{
	choice at A
	{
		1() from A to B;
		3() from B to C;
		4() from C to D;
	}
	or
	{
		2() from A to B;
		3() from B to C;
		5() from C to D;  // Not mergeable by ICALP13
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		3() from B to C;
		4() from C to B;
	}
	or
	{
		2() from A to B;
		3() from B to C;
		4() from C to B;
		5() from C to B;  // Tricky to check, e.g., output state sub-EFSMs are the same (cf. syntactic equality) for terminating the merge, maybe need strict isomorphism (without renaming)
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		0() from B to C;
		choice at A
		{
			1() from A to B;
			3() from B to C;
			4() from B to C;
		}
		or
		{
			2() from A to B;
			3() from B to C;
			5() from B to C;  // Consider EFSM of C for merging -- do non-det input squashing inductively, and only if no recursive edges back to original or preceding state? -- difficult to confirm, e.g., output state sub-EFSMs are the same (cf. syntactic equality) for terminating the merge, maybe need isomorphism
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		3() from B to C;
		4() from B to C;
	}
	or
	{
		2() from A to B;
		3() from B to C;
		//5() from B to C;  // Makes merge easier
		rec X
		{
			5() from B to C;  // Consider EFSM of C for merging
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		3() from B to C;
		3() from B to C;
		4() from B to C;
	}
	or
	{
		2() from A to B;
		3() from B to C;  // Merging (non-det input state "squashing") first messages only not enough (cf. inductive syntactic merge)
		3() from B to C;
		5() from B to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		choice at A
		//choice at B
		{
			continue X;
		}
		or
		{
			2() from A to B;
			//2() from B to A;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		choice at A
		{
			1a() from A to B;
			1a() from A to C;
		}
		or
		{
			1b() from A to B;
			1b() from A to C;
		}
	}
	or
	{
		2() from A to B;
		choice at A
		{
			2a() from A to B;
			2a() from B to C;
		}
		or
		{
			2b() from A to B;
			2b() from B to C;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		rec X
		{
			1() from A to B;
			continue X;
		}
	}
	or
	{
		2() from A to B;
	}
	3()	from C to A;
	3()	from C to A;  // Role-progress violation for C under WF_1
	choice at A
	{
		4() from A to B;
		5() from B to A;
	}
	or
	{
		4() from A to B;
		6() from B to A;
	}
}
//*/


/*
// Counter example to completeness of safety for current WF
global protocol Proto1(role A, role B, role C) {
	choice at A {
		1() from A to B;
		3() from B to C;
		4() from A to C;
	} or {
		2() from A to B;
		3() from B to C;
		5() from A to C;  // FIXME: should be mergable as a branch at C? (yes, by ICALP13) -- but requires treating non-det as det (i.e. language equiv. vs. bisim? -- local language minimisation wrt. inputs only?) -- in general, consider subsequent B and C interactions; but this exact example should be safe
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A t B;  // Testing Antlr error display overriding
}
//*/


/*
type <java> "java.lang.Integer" from "rt.jar" as Int;

global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;
	}
	or
	{
		1(Int) from A to B;  // Testing bad payloads
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		2() from B to C;
		3() from C to A;
	}
	or
	{
		4() 
		from A to B;
		5() from B to C;  // "Standard merge" (ICALP13) -- 2/5 cases merged for input choice at C  // but is it actually mergable in ICALP13/WADFEST? because only defined on branch, not select as needed for C here -- it's fine, only merging the top level branches (distinct labels)
		6() from C to A;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		2() from B to C;
		3() from C to A;
	}
	or
	{
		4() from A to B;
		2() from B to C;
		3() from C to A;  // Not mergeable by WADFEST, because continuations of C to be merged are not input-branches (but WAFDEST could probably be extended easily -- most simply by just allowing TmergeT for any T, not just branch -- more generally, would have to inductively coerce non-branches into branches, which is what the below example (i.e. WADFEST) is a special case of)
				// However, mergeable by ICALP13 (just a typo by WADFEST)
				// (WADFEST merges also only defined on branches, not receives, but receive can be easily converted to singleton branches? -- a point of directed branches is that they have no payloads, and receives have no labels, which Scribble needs to consider)
	}
}
//*/


/*
// Counter example to completeness of safety for current WF -- this notion of completeness is wrt. a global semantics, but not wrt. specific definition of Scribble projection/EFSM? (i.e. if we project/build a subsequent input choice at C from A, not just the initial one from B -- this is essentially mixing a ``non-choice'' (pre-determined flow) at A with an external choice at C -- i.e. ICALP13/WADFEST merge: convert non-det external choice into det non-choice followed by inductively merged (external choice) continuations) -- actually not necessarily, can consider still non-det, but just that the continuation branches are safe (but this view is more like inferring non-directly specified cases for nested branches)
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		2() from B to C;
		//choice at A {  // better for merging?
			3() from A to C;
		//}
	}
	or
	{
		1b() from A to B;
		2() from B to C;
		4() from A to C;  // FIXME: "merge/coerce" branches for C -- implement as some king of variant of "determinisation"? i.e. 2.3+2.4 -> 2.(3+4) (issue is it's not bisim preserving -- is local language minimisation a sound general principle? well, not for the minimal non-det branch example (or actually, yes? see below), but somehow only for "nested" external choices? i.e. same-label mergability?)
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;
		2() from B to A;  // FIXME: should we just language-equiv minimise endpoints? implicitly take that as the CFSM meaning of this global protocol? depends on global semantics -- but would make general projection/graphbuilding and mergability more uniform? -- uniformity should be the aim, see below -- no: not just independent EFSM minimisation, but should consider the whole CFSM system, see below
	}
	or
	{
		1() from A to B;
		3() from B to A;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;
		3() from B to C;
		4() from C to A;
	}
	or
	{
		2() from A to B;
		3() from B to C;
		5() from C to A;  // FIXME: language minimising at C will determinise, but minimising at A has no effect: minimising makes (non-det) external choice at C into internal choice, which is incompatible with original internal choice at A -- so independent language minimising is not sound -- basically syntactic branch-only merging restricts "determinising" to external choices only -- so do independent EFSM language-minimisation applied to inputs only? (but sometimes non-det outputs can be safely minimised -- but just leave them as is for global model checking?)
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
	}
	or
	{
		1() from A to B;  // Simply syntactically not representable with directed choice, but safe under the same intuition as mergability -- in this case, independent endpoint minimisation modifies both A and B consistently
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		2() from B to C;
		//choice at A
		//{
		//	4() from A to C;
		//}
		//or
		//{
		//	3() from A to C;
		//}
	do Proto1Aux(A, C); // WADFEST merge -- morally: WADFEST merge "infers" safe branche cases for nested branches -- can factor out by subprotos
					// NO: WADFEST prevents internal choice 4/5 by A, only allows external choice by C
	}
	or
	{
		1b() from A to B;
		2() from B to C;
		//choice at A
		//{
		//	4() from A to C;
		//}
		//or
		//{
		//	3() from A to C;
		//}
		do Proto1Aux(A, C);
	}
}

// Makes clear that TmergeT for any T should be OK
aux global protocol Proto1Aux(role A, role C)
{
	choice at A
	{
		3() from A to C;
	}
	or
	{
		4() from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		2() from B to C;
		3() from C to A;
	}
	or
	{
		4() from A to B;
		2() from B to C;
		5() from C to A;  // TODO: most general merge: coerce an external choice for A here -- less morally clear than, e.g., WADFEST restriction to branch-only merge though
	}
}
//*/


/*
type <java> "java.lang.Integer" from "rt.jar" as Int;

global protocol Proto1(role A, role B, role C)
{
	choice at A {
		buyer1(Int) from A to B;  // Total
		(Int) from B to A;        // B will pay this much
		buyer2(Int) from A to C;  // C will pay remainder
	} or {
		buyer1(Int) from A to C;  // Total
		(Int) from C to A;        // C will pay this much
		buyer2(Int) from A to B;  // B will pay remainder
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C, role D)
{
	..(syntactic) reachability tests
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		1() from A to C;
	}
	or
	{
		2() from A to B;
	}
	3() from A to C;  // TODO: "optional": needs empty actions and "empty-removal" transformation
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			1() from B to A;
			3() from A to C;  // Trying to find an unfair-transformation problem wrt. not visiting "2" case after "1" transitions
			continue X;
		}
		or
		{
			2() from A to B;
			2() from B to A;
			3() from A to C;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	2() from B to C;  // Testing CommandLine with, e.g., -fsm(dot) arg (disamb error before projection passes means graph cannot be built)
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A  // -oldwf, default, -fair
		{
			1() from A to B;
			continue X;
		}
		or
		{
			2() from A to B;
			//2() from A to C;
			2() from B to C;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		rec X
		{
			1() from A to B;
			continue X;
		}
	}
	or
	{
		2() from A to B;
	}
	3() from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		() from B to C;
		1() from B to A;
	}
	or
	{
		2() from A to B;
		() from B to C;  // Classic mergeability (no "equiv." protocol by sequencing -- unless maybe a generous async. equiv.)
		2() from B to A;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		2() from B to C;
		//3() from C to A;
		3() from C to B;
	}
	or
	{
		1() from A to B;
		5() from B to C;
		//6() from C to A;
		5() from C to B;  // Mergeable -- A not involved downstream
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		rec X
		{
			1() from A to B;
			1() from B to C;
			continue X;
		}
	}
	or
	{
		2() from A to B;
		2() from B to C;
	}
	3() from A to B;  // Sequencing after recursive-choice
	3() from B to C;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(Proto2@A) from A to B;  // Testing delegation payload projection
}

global protocol Proto2(role A, role B)
{
	2() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	(Proto1@A) from A to B;  // Testing recursive protocoldecls
}
//*/


/*
global protocol Proto1(role A, role B)
{
	(Proto2@A) from A to B;  // Testing recursive protocoldecls
}

global protocol Proto2(role A, role B)
{
	//(Proto1@A) from A to B;
	(Proto3@A) from A to B;
	//do Proto3(A, B);
}

global protocol Proto3(role A, role B)
{
	1() from A to B;
	//(Proto1@A) from A to B;
	//(Proto2@A) from A to B;
	//do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		4() from B to C;
	}
	or
	{
		2() from A to B;
		5() from B to C;  // Mergeable subset of choice cases (cf. syntactic merge?
		5() from C to B;
	}
	or
	{
		3() from A to B;
		5() from B to C;
		5() from C to B;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		do Game(A, B, C);
	}
	or
	{
		2() from A to B;
		2() from B to C;
	}
}

aux global protocol Game(role A, role B, role C)
{
	() from A to B;
	() from B to C;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		rec X
		{
			2() from A to B;
			//do Proto1Aux(A, B);
		}
	}
}

aux global protocol Proto1Aux(role A, role B)
{
	continue X;  // Still checked for aux
}
//*/


/*
global protocol Proto1<sig M>(role A, role B)
{
	do Proto1Aux<M>(A, B);
}

aux global protocol Proto1Aux<sig M>(role A, role B)
{
	M from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	(Test.Foo) from A to B;  // Testing DataType disamb
}
//*/


/*
type <java> "java.lang.Integer" from "rt.jar" as Int;

global protocol Proto1(role A, role B)
{
	Int from A to B;  // Testing disamb (and AST visitChild)
}
//*/


/*
sig <java> "..." from "..." as M;

global protocol Proto1(role A, role B)
{
	(M) from A to B;  // Testing disamb (and AST visitChild)
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect A to C;
	rec X
	{
		choice at A
		{
			1() from A to B;  // Testing "fair"/"unfair" liveness -- issue of global liveness vs. local subtyping) -- generating "unfair output subtyped" global model (can it be done simply by terminal set role check?)
			continue X;
		}
		or
		{
			2() from A to B;
		}
	}
	3() from A to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			continue X;
		}
		or
		{
			1() from A to B;  // Testing non-det unfairClone -- uninteresting test because non-det single-action-edge choice-merges get implicitly minimised (by graph building)
			continue X;
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			3() from B to A;
			continue X;
		}
		or
		{
			1() from A to B;  // Testing non-det unfairClone
			3() from B to A;
			//4() from B to A;
			continue X;
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect B to C;
	connect A to C;  // How does C "correlate" A/B connections to sessions -- introduces? -- need to study real examples
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	rec X
	{
		1() from A to B;
		connect B to C;  // C doesn't care whether each connection is new or old session?
		2() from B to C;
		disconnect B and C;
		continue X;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	disconnect A and B;
	connect A to B;  // What does it mean for B to leave the session and rejoin?  Need some condition like if fully leave, then rejoining should be same as new session? (i.e. this case bad) -- Consider implementability
	disconnect A and B;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	rec X
	{
		choice at A
		{
			1() from A to B;
			1() connect A to C;
			disconnect A and C;
			continue X;
		}
		or
		{
			2() from A to B;
			2() connect A to C;
			disconnect A and C;
			continue X
		}
	}
	connect A to C;  // Good until here, now bad because C already fully left?
	3() from A to C;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	rec X
	{
		connect A to B;  // What does this mean in terms of a "session"? (should consider the implementation, session id, ...) -- distinction between initial accept and in-session accepts?
		//1() from A to B;
		//1() from B to A;
		disconnect A and B;  // Shouldn't allow continuation after a certain point?  no session structure left?
		continue X;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		connect B to C;
		connect A to C;
		1() from A to C;
	}
	or
	{
		2() from A to B;
		connect A to C;  // Inconsistent choice connect subjects
	}
}
//*/

//***



/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		disconnect A and B;  // CHECKME: disconnect shouldn't have asymmetric src/dest -- check enabling conditions wrt. choices, projection, etc
	}
}
//*/


/*
type <java> "java.lang.Integer" from "rt.jar" as Int;

explicit global protocol Proto1(role A, role B)
{
	choice at A
	{
		1(Int) connect A to B;  // Testing non-det payloads for message-connects
	}
	or
	{
		1() connect A to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	rec X
	{
		choice at A
		{
			1() from A to B;
		}
		or
		{
			2() from A to B;
			2() connect B to C;
			2() from B to C;
			disconnect B and C;
		}
		or
		{
			3() from A to B;
			3() connect B to C;  // Cf. PartnershipSupplier filter subproto
			3() from B to C;
			disconnect B and C;
		}
		continue X;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			1() from B to C;
			rec Y
			{
				choice at B
				{
					3() from B to A;
					continue X;
				}
				or
				{
					4() from B to A;
					continue Y;  // Needs fairness
				}
			}
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			1() from B to C;
			choice at B  // C not involved, but still live (without fairness)
			{
				3() from B to A;
				continue X;
			}
			or
			{
				4() from B to A;
				continue X;
			}
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			1() from B to C;
			choice at B
			{
				3() from B to A;
				continue X;
			}
			or
			{
				rec Y  // Bad (fair or not)
				{
					4() from B to A;
					continue Y;
				}
			}
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			1() from B to C;  // Live, without fairness
			continue X;
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		rec X
		{
			1() from A to B;
			1() from B to C;
			continue X;
		}
	}
	or
	{
		2() from A to B;
		2() from B to C;  // CHECKME: bad sequence if commented, correct? -- bad sequence because C not in block so projection pruned, then only rec-block left -- is this satisfactory? (consider standalone global semantics vs. global as syntactic sugar for locals) -- however, "bad sequence" restriction probably does not hurt expressiveness
	}
	3() from B to C;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
	}
	rec X  // Testing non-fair EFSM generation
	{
		choice at B
		{
			3() from B to A;
			continue X;
		}
		or
		{
			4() from B to A;
		}
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		wrap B to A;
	}
	or
	{
		wrap A to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
		disconnect A and B;  // Testing unfairClone terminal state reconcilliation -- FIXME: this example doesn't actually test this, cf. SupplierInfoExplicit for requestor
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			continue X;
		}
		or
		{
			2() from A to B;
		}
	}
	//3() from A to C;  // Testing fair/unfair liveness for C
	3() from C to A;  // Message liveness also subject to fair/unfair
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		() from B to C;
		3() from B to A;
	}
	or
	{
		2() from A to B;
		() from B to C;  // choice + sequencing not the same as just syntactic sugar for factoring out a common branch continuation, i.e. cannot factor out "() from B" as a continuation without either losing causality for output to A or changing output order at B -- arguable that changing order at B is equivalent (for some equivalence), but not equivalent under basic bisimilarity
		4() from B to A;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;  // CHECKME: empty case for C discarded by projection, but do we need tau for correctness?  this example works because it ends up as stuck error -- a point is generating tau and then bisim-minimising doesn't remove the tau, whereas the current projection does remove the tau (so current projection is not equiv to bisim-minimisation intuition)
				// should be OK: intiution: an input-state endpoint cannot choose to not receive a message, i.e. input states should never have tau -- so whole system must satisfy properties when modelling "partial" local branches as a "complete" branch for just the involved choice cases (i.e. ignore any non-involved cases)
	}
	or
	{
		2() from A to B;
		2() from A to C;
	}
	3() from A to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			continue X;
		}
		or
		{
			2() from A to B;
		}
	}
	3() from A to C;  // Not "strongly" live for C -- by subtyping, an implementation of A may never terminate -- strongly live probably means all roles have to be involved in every choice path -- not quite: it all depends on definition of subtyping, could make a "live" notion of subtyping that doesn't allow a non-live subset of choices -- this also depends on the select primitives and typing rules (it could come down to decidability of if-conditions...) -- problem is, even without subtyping, select primitive is always about selecting just one case, can't really make a "live" typing on top of that... -- could be positioned as basic session typing needs strong liveness, while weak liveness can be aimed at assuming a more general program verification -- or maybe a more powerful "imperative style" typing system could work, e.g. while (...) { ..non-live choice on s..} ..live choice on s.., i.e. it is ok to select a non-live case if the while will terminate to eventually lead us to a live case.. -- this fairness/liveness issue is another "bondary" issue between modelling/types/practice, bit like linearity
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
//explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		1() from A to B;
		connect A to C;  // Testing API gen (without I/O i/f gen)
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A  // Testing minfsm
	{
		1() from A to B;
		2() from B to A;
	}
	or
	{
		1() from A to B;
		2() from B to A;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	2() from A to B;
	rec X
	{
	choice at A
	{
		1() from A to B;
		1() from A to B;
	}
	or
	{
		1() from A to B;  // Testing minfsm
		1() from A to B;
	}
	continue X;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	2() from A to B;
	rec X
	{
	choice at A
	{
		1() from A to B;  // Testing minfsm
	}
	or
	{
		1() from A to B;
		1() from A to B;
	}
	continue X;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect A to C;  // Bad
	disconnect A and C;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		1() from A to B;
		connect B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect A to C;
	choice at A
	{
		1() from A to B;
		1() from A to C;
		connect B to C;
		2() from A to B;
	}
	or
	{
		1() from A to B;
		1() from A to C;
		connect B to C;  // Good: mergeable
		2() from A to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect A to C;
	choice at A
	{
		1() from A to B;
		1() from A to C;
		connect B to C;
		2() from A to B;
	}
	or
	{
		1() from A to B;
		1() from A to C;
		connect C to B;  // If A and C are in above, 2() can be stuck at B's connect/accept here -- but stuck error not directly detected, error manifests as B/C deadlock
		2() from A to B;  // Mergeable if B/C connection not deadlocked
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		connect B to C;
	}
	or
	{
		1() from A to B;
	}
	2() from B to C;  // Trying to make an unconnected orphan from B to C, but currently will always get a connectedness error first -- model building semantics shouldn't/won't allow explicit unnconnected orphans, message cannot be sent if not connected
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to C;
	connect C to B;
	choice at A
	{
		1() from A to C;
		connect A to B;
	}
	or
	{
		2() from A to C;
		2() from C to B;  // Bad: connect and msg from different choice subjects
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A
		{
			connect A to B;  // Good: tests recursion pruning for connection actions
		}
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A  // ** using old WF, this breaks connectedness checking -- WFChoiceChecker is an UnfoldingVisitor, but it is prunes the visit on entering the unfolded choice
		{
			connect A to B;
			continue X;  // Bad
		}
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	rec X
	{
		choice at A
		{
			1() from A to B;
			connect B to C;
			disconnect B and C;  // Comment is bad
			continue X;
		}
		or
		{
			2() from A to B;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			2() from A to C;
			1() from A to B;
		}
		or
		{
			2() from A to C;
			2() from C to A;
			2() from A to B;
		}
		continue X;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	// Disable local choice subject inference
	rec X
	{
  	// Testing getTrace?
		choice at A
		{
			1() from A to B;
			//1() from A to B;
			1() from A to C;
			3() from B to C;
			continue X;
		}
		or
		{
			1() from A to B;
			2() from B to C;
			3() from C to B;
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	// Disable local choice subject inference
	rec X
	{
		// Testing getTrace?
		choice at A
		{
			1() from A to B;
			continue X;
		}
		or
		{
			1() from A to B;
			1() from A to C;
			2() from C to B;
			continue X;
		}
		or
		{
			3() from A to C;
			3() from C to B;
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A
		{
			1() from A to B;  // Testing graph building
		}
		or
		{
			1() from A to B;
		}
		continue X;
	}
}
//*/


/*
global protocol Partners(
		role LOGINsvc,
		role REQUESTOR,
		role AUTHsvc,
		role FILTERsvc,
		role SUPPLIERsvc,
		role CONTRACTsvc)
{
	login() from REQUESTOR to LOGINsvc;
	choice at LOGINsvc
	{
		loginfailure() from LOGINsvc to REQUESTOR;
		0() from REQUESTOR to AUTHsvc;
		0() from AUTHsvc to FILTERsvc;
		0() from AUTHsvc to SUPPLIERsvc;
		0() from AUTHsvc to CONTRACTsvc;
	} or {
		loginsuccess() from LOGINsvc to REQUESTOR;
		rec MAIN
		{
			choice at REQUESTOR
			{
				getsuppliers() from REQUESTOR to AUTHsvc;
				choice at AUTHsvc
				{
					getsuppliers() from AUTHsvc to SUPPLIERsvc;  // Bad: testing getTrace performance
					deny() from AUTHsvc to REQUESTOR;
				} or {
					getsuppliers() from AUTHsvc to SUPPLIERsvc;
					suppliers() from SUPPLIERsvc to AUTHsvc;
					filterSuppliers() from AUTHsvc to FILTERsvc;
					filtered() from FILTERsvc to AUTHsvc;
					suppliers() from AUTHsvc to REQUESTOR;
				}
			} or {
				getcontracts() from REQUESTOR to AUTHsvc;
				choice at AUTHsvc
				{
					deny() from AUTHsvc to REQUESTOR;
				} or {
					getcontracts() from AUTHsvc to CONTRACTsvc;
					contracts() from CONTRACTsvc to AUTHsvc;
					filterContracts() from AUTHsvc to FILTERsvc;
					filtered() from FILTERsvc to AUTHsvc;
					contracts() from AUTHsvc to REQUESTOR;
				}
			}
			continue MAIN;
		}
	}
}
//*/


/*
global protocol Proto1
(
		role REQuestor,
		role AUTHsvc,
		role SUPPLIERsvc,
		role CONTRACTsvc)
{
	rec MAIN
	{
		choice at REQuestor
		{
			getsuppliers() from REQuestor to AUTHsvc;
			choice at AUTHsvc
			{
				getsuppliers() from AUTHsvc to SUPPLIERsvc;  // Bad: testing getTrace
				deny() from AUTHsvc to REQuestor;
			} or {
				getsuppliers() from AUTHsvc to SUPPLIERsvc;
				suppliers() from SUPPLIERsvc to AUTHsvc;
				suppliers() from AUTHsvc to REQuestor;
			}
		} or {
			getcontracts() from REQuestor to AUTHsvc;
			choice at AUTHsvc
			{
				deny() from AUTHsvc to REQuestor;
			} or {
				getcontracts() from AUTHsvc to CONTRACTsvc;
				contracts() from CONTRACTsvc to AUTHsvc;
				contracts() from AUTHsvc to REQuestor;
			}
		}
		continue MAIN;
	}
}
//*/



/*
global protocol Proto(role A, role B)
{
	choice at A
	{
		1() from A to B;
		disconnect A and B;
	}
	or
	{
		1() from A to B;
		2() from B to A;  // B can still send even if A disconnects (async) -- so not wait-for from that situation
	}
}
//*/


/*/
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;

		1() from A to C;
		1() from A to C;

		3() from C to B;
	}
	or
	{
		1() from A to B;

		() from B to C;  // Trying to get A into above block while C is in here, such that WF1 forces C also into the above -- so that WF1 becomes unsound
		2() from A to C;

		4() from C to B;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at C
	{
		1() from C to B;
		1() from C to A;
	}
	or
	{
		1() from C to B;
		2() from C to A;

		2() from A to B;
		2() from A to B;

		2() from A to C;

		2() from C to B;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		rec X
		{
			choice at A
			{
				1() from A to B;
				continue X;
			}
		}
	}
	or
	{
		2() from A to B;
	}

	2() from C to B;  // TODO: investigate: WF_1 won't get past here, is it OK?
	2() from C to B;  // ..becomes "fake" role liveness problem because of WF1 -- not live even assuming fairness
	// ..dragons

	// TODO: investigate reachability of local states in global model
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at B
	{
		0() from B to C;
		0() from B to A;
		2() from C to B;
		choice at A
		{
			rec X
			{
				choice at A
				{
					1() from A to B;
					continue X;
				}
			}
		}
		or
		{
			2() from A to B;
		}
	}
	or
	{
		0() from B to C;
		1() from B to A;
		2() from C to B;  // Good
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at B
	{
		0() from B to C;
		0() from B to A;

		//2() from C to B;
		//2() from C to B;

		choice at A
		{
			rec X
			{
				choice at A
				{
					1() from A to B;
					//2() from C to B;
					continue X;
				}
			}
		}
		or
		{
			2() from A to B;
		}
	}
	or
	{
		0() from B to C;
		1() from B to A;
	}

	2() from C to B;  // TODO: investigate: WF_1 won't get past here, is it OK?
	2() from C to B;  // ..becomes "fake" role liveness problem because of WF1
	// ...

	// TODO: investigate reachability of local states in global model
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	// Trying to construct a counterexample for WF1 soundness..
	// ..need to find an error state that is unreachable by WF1 but reachable by e.g. WF2
	// Try to find a choice where B is falsely committed to a branch due to WF1 (so state space of model is unsoundly restricted)
	choice at A
	{
		1() from A to B;
		1() from A to B;
		2() from A to C;  // A cannot do this in WF1 unless B receives a 1() first
	}
	or
	{
		3() from A to C;
		//2() from A to B;
				// Local choice subjects require B to also receive from A in this block
				// Two cases: same or different label
				// If different label, then no possibility of false branch commitment
				// If same label, then non-det always allows B to enter this block, even under WF1
				// Therefore: false choice commitment not possible
		1() from A to B;
		1() from A to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B  // Good non-det EFSM for A (including minimisation)
		connect A to C;
	}
	or
	{
		1() from A to B;
		//connect A to C;  // Tests -minfsm
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	// Needs local choice subject disabled, though the point is it's still bad
	choice at A
	{
		a() from A to B;
		//d() from C to B;  // Moved down to make C enabled
		cprime() from A to C;
		d() from C to B;
		b() from B to A;
		y() from A to B;  // Orphan
	}
	or
	{
		c() from A to C;
		d() from C to B;  // ..point is B could get in this case, while A (and C) are in the other
		b() from B to A;
		a() from A to B;  // (..not stuck msg error because the a() from above is consumed here)
		x() from B to A;  // Orphan
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	// Counterexample for WF1 if local choice subject disabled
	choice at A
	{
		a() from A to B;
		a() from A to B;  // WF1 unnaturally resolves the non-det choice at B by forcing B to commit to this branch before C is enabled
		cprime() from A to C;
		d() from C to B;
		b() from B to A;

		//y() from A to B;  // Potential orphan
	}
	or
	{
		c() from A to C;
		d() from C to B;
		b() from B to A;  // Must come before a's, to prevent reverse choice race
		a() from A to B;
		a() from A to B;

		//x() from B to A;  // Potential orphan
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	// Disable local choice subject inference -- mergeable
	choice at A
	{
		1() from A to B;
		1() from A to B;
		1() from A to C;
		2() from C to B;
	}
	or
	{
		2() from A to C;
		2() from C to B;
		1() from A to B;
		1() from A to B;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		1() from A to B;
		1() from A to C;
		2() from C to B;

		3() from B to C;
	}
	or
	{
		2() from A to C;
		2() from C to B;
		1() from A to B;
		1() from A to B;

		//3() from B to C;
		4() from B to C;  // Bad
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		1() from A to B;
		1() from A to C;
		2() from C to B;
		2() from C to B;

		3() from B to C;  // Should be potential stuck
	}
	or
	{
		2() from A to C;
		2() from C to B;
		2() from C to B;
		() from C to A;  // Another counterexample to WF1 (B falsely committed to here when A/C are)
		1() from A to B;
		1() from A to B;

		4() from B to C;  // Should be potential stuck
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		continue X;  // Test graph building: EndpointGraph null exit
	}
}
*/










































































/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		connect from B to C;
		1() from B to C;
	}
	or
	{
		2() from A to B;
		connect from B to C;
		2() from B to C;  // Not mergeable (connect/accept is unit message)
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	// Good
	connect A to B;
	connect A to C;
	connect B to C;  // Test wait-for error detection: C is non-initial accept, but B is a corresponding connect
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	// Bad
	connect A to B;
	connect A to C;
	0() from A to C;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
		connect B to C;  // Test safe termination check for non-initial accept states
		3() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	// Good
	connect A to B;
	connect A to C;
	0() from A to C;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
	}
	connect B to C;
	3() from B to C;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect A to C;
	0() from A to C;
	choice at A
	{
		rec X
		{
			1() from A to B;
			continue X;
		}
	}
	or
	{
		2() from A to B;
	}
	connect B to C;  // Tests role liveness check for non-terminal (accept) states
	3() from B to C;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;  // Basic test for connection deadlock detection
	1() from A to B;
}
//*/



/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
		connect B to C;  // Good because C is initial
		2() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect A to C;
	choice at A
	{
		1() from A to B;
		1() from A to C;
		connect B to C;
	}
	or
	{
		1() from A to B;
		1() from A to C;
		connect C to B;  // Deadlock
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect A to C;
	choice at A
	{
		1() from A to B;
		1() from A to C;
		connect B to C;
		2() from B to C;
	}
	or
	{
		1() from A to B;
		1() from A to C;
		connect B to C;  // Good
		2() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C, role D)
{
	connect A to B;
	connect A to C;
	connect A to D;
	choice at A
	{
		1() from A to B;
		1() from A to C;
		1() from A to D;
		connect B to C;
	}
	or
	{
		1() from A to B;
		1() from A to C;
		1() from A to D;
		connect C to D;
	}
	or
	{
		1() from A to B;
		1() from A to C;
		1() from A to D;
		connect D to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C, role D)
{
	connect A to B;
	connect A to C;
	connect A to D;
	// Good
	choice at A
	{
		1() from A to B;
		1() from A to C;
		1() from A to D;
		connect B to C;
		connect C to D;
		connect D to B;
	}
	or
	{
		1() from A to B;
		1() from A to C;
		1() from A to D;
		connect B to C;
		connect C to D;
		connect D to B;
	}
	or
	{
		1() from A to B;
		1() from A to C;
		1() from A to D;
		connect B to C;
		connect C to D;
		connect D to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		connect A to C;
		3() from A to C;
	}
	or
	{
		connect A to C;  // Mixed send/connect state at A
		2() from A to B;
		3() from A to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect from A to B;
	choice at A
	{
		rec X
		{
			choice at A
			{
				1() from A to B;
				continue X;
			}
			or
			{
				//3() from A to B;  // Uncomment is fix
			}
		}
	}
	or
	{
		2() from A to B;
	}
	connect from C to B;  // Not role live: connect is a sync action
	3() from C to B;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect from A to B;
	choice at A
	{
		rec X
		{
			choice at A
			{
				1() from A to B;
				continue X;
			}
		}
	}
	or
	{
		2() from A to B;
	}
	connect from B to C;  // Good: connect is a sync action, but "asymmetric"
	3() from C to B;
}
//*/


/*  // disconnect
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		1() from B to C;
		disconnect B and C;
		rec X
		{
			1() from A to B;
			continue X;
		}
	}
	or
	{
		2() from A to B;
		2() from B to C;
	}
	3() from A to B;
	//3() from B to C;  // Uncomment is bad
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	// Good
	connect A to B;
	connect A to C;
	choice at A
	{
		1() from A to B;
		1() from A to C;
	}
	or
	{
		2() from A to B;
		2() from A to C;
		connect B to C;
		disconnect B and C;
	}
	connect B to C;
	2() from B to C;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	1() from A to B;
	choice at A
	{
		1() from A to B;
		disconnect A and B;
	}
	or
	{
		2() from A to B;
		disconnect A and B;
	}
	3() from A to B;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	1() from A to B;
	choice at A
	{
		1() from A to B;
		disconnect A and B;
	}
	or
	{
		2() from A to B;
	}
	3() from A to B;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	do Proto1Aux(A, B, C);
}

aux global protocol Proto1Aux(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		//connect B to C;  // Bad if non-det
		1() connect B to C;
		1() from B to C;
		disconnect B and C;
		do Proto1Aux(A, B, C);  // FIXME: guarded do has same subprotsig has an unguarded one (and ProjectedSubprotPruner is using subprotsigs...) -- but current problem is actually ambiguous connect enabling of C by B -- anyway to have explicit protocol with multiple instances of the same do-subprotsig with and without choice-guards?
			// TODO: this doesn't just break subprot pruning, but affects whole subprot visiting framework because using current subprot "cycles" may not provide coverage of all "full recursive loops" (cf. unfolding/unrolling all rec/continues) -- current framework gives coverage only if recursive subprots are only called from a single "location" -- maybe fixable by generalising subprotsigs record more than just the immediate proto+args context -- luckily some analyses like enabling check are OK despite this
			// basically: current subprotocolsigs do identify a common "state" entry, but cannot be used to identify "specific" cycle paths or "maximal recursion paths"
	}
	or
	{
		4() from A to B;
		do Proto1Aux(A, B, C);
	}
	or
	{
		2() from A to B;
		//connect B to C;  // Bad if non-det
		2() connect B to C;
		2() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	// Good
	connect A to B;
	connect B to C;
	1() from A to B;
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux1(role A, role B, role C)
{
	choice at A
	{
		3() from A to B;
		3() from B to C;
		do Proto1Aux2(A, B, C);
	}
	or
	{
		4() from A to B;
		4() from B to C;
		//do Proto1Aux2(A, B, C);
	}
}

aux global protocol Proto1Aux2(role A, role B, role C)
{
	choice at A
	{
		5() from A to B;
		do Proto1Aux1(A, B, C);  // Testing graph building (C vs. A/B)
		//do Proto1Aux2(A, B, C);
	}
	or
	{
		6() from A to B;
		//connect B to C;
		6() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect B to C;
	1() from A to B;
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux1(role A, role B, role C)
{
	choice at A
	{
		3() from A to B;
		//3() from B to C;
		do Proto1Aux2(A, B, C);  // Testing mutually choice-unguarded "prunable" do's
	}
}

aux global protocol Proto1Aux2(role A, role B, role C)
{
	choice at A
	{
		5() from A to B;
		do Proto1Aux1(A, B, C);
		//do Proto1Aux2(A, B, C);
	}
	or
	{
		6() from A to B;
		//connect B to C;
		6() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1() from A to B;
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux1(role A, role B, role C)
{
	do Proto1Aux2(A, B, C);
}

aux global protocol Proto1Aux2(role A, role B, role C)
{
	choice at A
	{
		2() from A to B;
		do Proto1Aux1(A, B, C);
	}
	or
	{
		3() from A to B;
		connect B to C;
		4() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect B to C;
	1() from A to B;
	//1() from B to C;
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux1(role A, role B, role C)
{
	() from A to B;
	//() from B to C;
	do Proto1Aux2(A, B, C);
}

aux global protocol Proto1Aux2(role A, role B, role C)
{
	choice at A
	{
		2() from A to B;
		do Proto1Aux1(A, B, C);
		//do Proto1Aux2(A, B, C);
	}
	or
	{
		3() from A to B;
		//connect B to C;
		4() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	do Proto1Aux(A, B, C);
}

aux global protocol Proto1Aux(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		do Proto1Aux(A, B, C);  // ProjectedSubprotocolPruner
	}
	or
	{
		2() from A to B;
		connect B to C;
		3() from B to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		rec X
		{
			2() from A to B;
			continue X;
		}
	}
	or
	{
		3() from A to B;
	}
	connect A to C;  // Good
	4() from A to C;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	connect B to C;
	1() from A to B;
	choice at B
	{
		rec X
		{
			2() from B to C;
			continue X;
		}
	}
	or
	{
		3() from B to C;
	}
	connect A to C;  // Bad: role liveness
	4() from A to C;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		//2() from A to B;  // Uncomment bad
	}
	or
	{
		1() from A to B;
		rec X
		{
			connect B to C;
			4() from B to C;
			5() from C to B;
			disconnect B and C;
			continue X;
		}
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C, role D)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		1() from B to A;
		connect B to C;
		connect C to D;
	}
	or
	{
		1() from A to B;
		1() from B to A;
		connect B to D;
		connect D to C;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		connect A to B;
		//connect B to C;  // Uncomment bad
	}
	or
	{
		connect A to C;
	}
}
//*/


/*
type <java> "java.lang.Integer" from "rt.jar" as Int1;
type <java> "java.lang.Integer" from "rt.jar" as Int2;

explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux1(role A, role B, role C)
{
	choice at B
	{
		1() from B to A;
		do Proto1Aux2<Int1>(A, C);
	}
	or
	{
		2() from B to A;
		do Proto1Aux2<Int2>(A, C);
	}
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux2<type T>(role A, role C)
{
	// Bad: non-det connect followed by distinct payloads
	connect A to C;
	3(T) from A to C;
	4() from C to A;
	disconnect A and C;
}
//*/


/*
type <java> "java.lang.Integer" from "rt.jar" as Int1;
type <java> "java.lang.Integer" from "rt.jar" as Int2;

explicit global protocol Proto1(role A, role B, role C)
{
	// Good by basic model checking, but..
	connect A to B;
	connect A to C;
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux1(role A, role B, role C)
{
	choice at B
	{
		1() from B to A;
		do Proto1Aux2<Int1>(A, C);
	}
	or
	{
		2() from B to A;
		do Proto1Aux2<Int2>(A, C);  // Bad: payload
	}
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux2<type T>(role A, role C)
{
	3(T) from A to C;
	4() from C to A;
}
//*/


/*
// Good: same payload
type <java> "java.lang.Integer" from "rt.jar" as Int1;

explicit global protocol Proto1(role A, role B, role C)
{
	// Good
	connect A to B;
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux1(role A, role B, role C)
{
	choice at B
	{
		1() from B to A;
		do Proto1Aux2<Int1>(A, C);
	}
	or
	{
		2() from B to A;
		do Proto1Aux2<Int1>(A, C);
	}
	do Proto1Aux1(A, B, C);
}

aux global protocol Proto1Aux2<type T>(role A, role C)
{
	connect A to C;
	3(T) from A to C;
	4() from C to A;
	disconnect A and C;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect from A to B;
	do Proto1Aux(A, B);
}

aux explicit global protocol Proto1Aux(role A, role B)
{
	1() from A to B;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	// Basic connectedness tests
	connect A to B;
	//connect B to A;
	disconnect A and B;
	//1() from A to B;
	//disconnect A and B;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	rec X
	{
		choice at A
		{
			1() from A to B;
			connect B to C;
			2() from B to C;
			connect C to A;
			3() from C to A;
			//3() from A to B;  // Uncomment OK
			disconnect B and C;
			disconnect C and A; // Comment bad
			continue X;
		}
		or
		{
			4() from A to B;
		}
	}
	//disconnect A and C;  // Uncomment bad
	disconnect A and B;
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	rec X
	{
		choice at B
		{
			// Good, even though A not involved here
			connect B to C
			2() from B to C;
			3() from C to B;
			disconnect B and C;
			continue X;
		}
		or
		{
			4() from B to A;
		}
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	rec X
	{
		connect A to B
		1() from A to B;
		2() from B to A;
		disconnect A and B;
		connect B to A
		3() from A to B;
		4() from B to A;
		disconnect B and A;
		continue X;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	disconnect A and B;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	rec X
	{
		connect A to B;
		choice at A
		{
			1() from A to B;
			//continue X;  // Uncomment bad
		}
		or
		{
			2() from A to B;
		}
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		rec X
		{
			connect B to C;
			1() from B to C;
			//continue X;  // Uncomment bad
		}
	}
	or
	{
		2() from A to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C, role D)
{
	connect A to B;
	1() from A to B;
	//connect D to C;  // Uncomment OK
	1() from C to D;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;  // Comment bad
	1() from A to B;
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	choice at A
	{
		connect A to B;
		1() from A to B;
	}
	or
	{
		2() from A to B;  // Bad: caught syntactically -- this blocked choice case won't manifest as an error state in the presence of a non-blocked co-case
		// FIXME: could add implicit error actions (e.g. unconncted message passing) to model building, to make error states explicit
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	choice at A
	{
		connect A to B;
		1() from A to B;
	}
	or
	{
		connect A to B;
		2() from A to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	// Good
	connect A to B;
	choice at B
	{
		1() from B to A;
	}
	or
	{
		2() from B to A;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	choice at B
	{
		connect A to B;  // Bad
		1() from B to A;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	choice at A
	{
		connect A to B;
		1() from B to A;  // Good
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	choice at B  // Good
	{
		1() from B to A;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	choice at A
	{
		1() from A to B;
		rec X
		{
			connect B to C;
			1() from B to C;
			//continue X;  // Uncomment bad
		}
	}
	or
	{
		2() from A to B;
	}
}
//*/


/*
explicit global protocol Proto1(role A, role B)
{
	connect A to B;
	//connect A to B;  // Uncomment bad
	//connect B to A;  // Uncomment bad
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1() from A to B;
	//connect A to C;  // Uncomment OK
	2() from A to C;
}
//*/

